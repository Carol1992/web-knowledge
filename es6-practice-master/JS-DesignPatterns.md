# Javascript设计模式

### 设计模式的介绍
1. 价值所在：找到代码中重复出现的主题并优化它们。
2. 模式是一种可复用的、已经验证的解决方案，比如jQuery就使用外观模式提供接口给开发者使用，以选择元素为例，jQuery会在幕后选择最佳的元素选择方式，我们只需要使用抽象层就好。jQuery框架是有考虑浏览器兼容性问题和最佳性能的。
3. 设计模式的结构：上下文、上下文产生的元件系统、解决元件在上下文中自身问题的配置。没有交互和明确规则的解决方案就不是模式。
4. 模式描述的是能够解决重复出现的问题的业经验证的解决方案；最佳实践；有大量成功的示例；对用户体验是透明的，不会因为使用这些模式而需要用户改变其行为来配合。
5. 反模式：描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；描述如何摆脱前述的糟糕情况以及如何创造好的解决方案。
6. JavaScript的反模式：在全局中定义大量的全局变量；已内联形式使用JavaScript；修改Object的原型；向setTimeout或setInterval传递字符串而不是函数。一旦能够辨别反模式，我们将能够通过重构代码来防止它们的出现。
7. 设计模式类别：创建型设计模式，包括构造器、工厂、抽象、原型、单例、生成器；结构型设计模式：装饰者、外观、享元、适配器、代理；行为设计模式：迭代器、中介者、观察者、访问者。有23种设计模式。

### 构造器原型模式

### 模块闭包模式

### 揭示模块模式
1. 跟模块模式一样，只是返回的是一个对象，该对象的key/value分别对应模块对外输出的函数名称/函数实体。

### 单例模式
1. 限制了类的实例化次数只能一次。在实例不存在的情况下，可以通过一个方法创建一个类的新实例；如果实例已经存在，它会简单返回该对象的引用。单例不同于静态类或对象，因此我们可以推迟它们的初始化，这通常是因为它们需要一些信息，而这些信息在初始化期间可能无法获取。

### 观察者模式
1. 一个对象维持一系列依赖它的对象，将有关状态的任何变更自动通知给它们。当一个目标需要告诉观察者发生了什么有趣的事情，它会像观察者广播一个通知；当我们不希望某个特定的观察者获得通知，可以将其从观察者列表中删除。
2. 与发布/订阅模式的差别：观察者模式要求希望接收到主题通知的观察者必须订阅内容改变的事件；发布/订阅模式则允许任何订阅者执行适当的事件处理程序来注册和接收发布者发出的通知。
3. Vue.js 也是通过这个模式来实现数据驱动视图的。
4. 解耦基于ajax的jQuery应用程序：使用ajax调用一次数据源，然后发布出去，可能有多个订阅者订阅，每个订阅者对订阅到的数据做出不同的操作。

### 中介者模式
1. 促进模式松散耦合，确保组件的交互是通过中介者这个中心点来处理的，而不是显式地引用彼此。
2. DOM事件委托和事件冒泡，如果系统中所有的订阅针对的是文档document而不是单个node节点，则这个文档会有效充当中介者。

### 原型模式
1. 基于现有模板，通过克隆方式创建对象的模式。
2. Object.create(prototype, options) 

### 命令模式

### 外观模式

### 工厂模式

### 混入模式

### 装饰者模式

### 享元模式

### JavaScript的MV*模式
1. MVC 依赖于观察者模式来实现它的一些核心通信，当模型被改变时，它通知其观察者一些内容已经更新，这也许是MVC中最重要的关系。
2. MVC 解耦模型与视图，使得整体维护更加容易

### 模块化的JavaScript设计模式

### jQuery中的设计模式

### jQuery插件设计模式